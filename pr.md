> 난이도에 맞는 템플릿을 선택해서 작성해주세요!

---

## 7주차 과제 체크포인트

### 기본

# HARD

## 7주차 과제 체크포인트

### 기본과제

- [x] 총 11개의 파일, 115개의 단위 테스트를 무사히 작성하고 통과시킨다.

#### 질문

> Q. handlersUtils에 남긴 질문에 답변해주세요.

> 일단 문제는 handler에서 json을 수정하는 handler가 전역으로 설정 되어있다는 점이다.
> 병렬적으로 테스트가 실행될경우 모두가 같은 json을 수정하게되는 것이 문제다.

- 어떻게하면 병렬적으로 테스트할 때 독립적으로 실행시킬까?

  1. test마다 독립적으로 events를 셋팅해야한다.
  2. test마다 server handler가 독립적으로 동작해야한다.

짱돌을 계속 굴려봐도 API자체에서 수정하는 내용이다보니 events를 독립적으로 셋팅하려면 결국 테스트마다 새로 handler를 생성해야되는게 아닌가? 라는 결론을 지었다.

- 어떻게 테스트마다 새로 핸들러를 셋팅할 수 있을까?

1. 테스트마다 setupServer 설정하기
   https://mswjs.io/docs/api/setup-server

   While we commend setting up request interception globally, as a part of your testing setup, you may also use setupServer in individual tests, if you want to. Just make sure to choose one pattern and follow it throughout your tests—multiple setupServer calls is not a good idea!

   공식문서를 참고해봤을 때 setupServer는 글로벌로 한번 선언하거나, 테스트별로 설정해야한다고 적혀있다.

   중복으로 선언해서는 안된다.

   지금 구조에서 setupServer를 테스트마다 동작시키려면, global로 mocking하고 있는 로직을 제거해야한다.

   이렇게되면 독립적으로 이벤트 핸들러를 동작시킬 수는 있지만,
   특별히 다르게 동작해야될 이유가 없는 곳에서도 불필요하게 매번 setupServer 로직을 넣어줘야한다.

   더 좋은 방법이 없을까?

2. handler override 하기
   https://mswjs.io/docs/best-practices/network-behavior-overrides/#resetting-request-handlers

   override를 할 수 있는 방법이 없을까 찾아보던중 문서 제목이 override인 내용을 찾았다.

   server.use()와 resetHandlers()를 사용하면 내가 해결하고자 했던 내용을 풀어낼 수 있었다.

   1. 전역적으로 setup server handler들이 존재
   2. 테스트 내부에서 각각 handler를 use()함수를 통해 override를 해줘서 다르게 동작시킨다.
   3. override한 테스트에서는 테스트가 끝날 때 resetHandlers()를 실행시켜 원상복구

   그림으로 그려보면 이런 모습이지 않을까?
   <img width="482" height="343" alt="image" src="https://github.com/user-attachments/assets/d0dd6417-abc7-4d18-8ac4-40a78842a419" />

   > Q. 테스트를 독립적으로 구동시키기 위해 작성했던 설정들을 소개해주세요.
   > 위에서 작성한 내용처럼 server.use() resetHandlers()를 사용하였다.

- ex)

```ts
export const setupMockHandlerCreationError = () => {
  afterEach(() => {
    server.resetHandlers();
  });

  server.use(
    http.post('/api/events', () => {
      return HttpResponse.json({ message: 'Error' }, { status: 500 });
    })
  );
};
```

### 심화 과제

- [ ] App 컴포넌트 적절한 단위의 컴포넌트, 훅, 유틸 함수로 분리했는가?
- [ ] 해당 모듈들에 대한 적절한 테스트를 5개 이상 작성했는가?

ㅎㅎㅎ... 안했습니다...
아니.. 못했습니다..

## 과제 셀프회고

테스트코드는 나의 관심사도 아니였고, 스타트업에서 과연 필요한 내용일까? 싶은 의구심도 갖고 있었다.
그러다보니 당연히 테스트코드 자체를 처음 공부해봤다.

공부해본 후기로는 이녀석.. 우리 회사에서도 당장 하나씩 사용해봐도 괜찮겠는데...? 라는 생각을 했다.
회사에는 핵심기능이 옷편집, 옷등록, 코디등록 등등 앱 초기부터 있었던 기초기능이있다.
해당 기능들을 개선하거나 고도화할 때마다 레거시 코드들이 어떻게 동작하고 있는것이고, 기획도 잘 모르겠고, 기대값도 뭔지 모르겠는 경우가 많다.
이런 곳에 테스트코드를 도입해놓으면, 안정적으로 개발할 수 있을 것 같고 팀원들에게 도입을 고려해보자고 전달해둔 상태이다.

과제는 난이도를 선택할 수 있었는데, 나는 hard를 선택하였다.
테스트코드는 완전 처음 접해보긴하지만, hard 테스트 코드를 전부 수행해야지 공부했다고 느낄 수 있을 것 같았고
심화과제는 처음부터 포기하고, 테스트코드를 학습하자는 목표를 갖고 과제에 임했다.
테스트코드를 다 작성하고 리팩토링하는 과정도 겪어보고 싶었지만, 테스트코드만으로도 쉽지 않은 주간이었다.

과제 탈락을 보는 것은 너무 슬프지만, hard고른 곳을 후회하지 않는다! 테스트코드를 학습했으니까!!!

<!-- 과제에 대한 회고를 작성해주세요 -->

### 기술적 성장

<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

## 테스트 코드의 이해

### Testing Library??? Jest?? Vitest??

이번에 발제를 들으면서 테스팅 라이브러리는 뭐고, jest와 vitest는 무엇이지 정리가 되지 않았다.

- Vitest, Jest
  vitest와 jest는 테스트 코드를 실행하는 러너이다.
  테스트코드를 실행시키고 결과물을 출력해주는 시스템이다.

- Testing Library?
  vitest와 jest를 이용하여 테스트를 돌릴 수 있게 해주는 도구이다.

약간 진격의거인 세계관으로 비교해보자면,,
testing library는 입체기동장치
test는 거인
vitest, jest는 조사병단, 주둔병단
이런 느낌이랄까..?

### 테스트 작성 방법

테스트 코드를 작성하는 방식에는 두가지 방식이 있다.

1. 구현 기반 테스트
   구현 기반 테스트는 구현 세부사항에 따라서 개발자 관점, 코드 구조 기반으로 작성하는 방식이다.
   내부 로직에 대해서 커버리지가 높다.

2. 명세 기반 테스트
   명세 기반 테스트는 사용자 관점, 요구사항 문서에 따라서 작성하는 방식이다.

예를 들어서 "초기 상태에서는 알림이 없어야 한다" 라는 테스트를 진행할 때 알람이 없어야 한다는 명세 기반 테스트일까 구현 기반 테스트일까?

테스트 코드를 작성해보았다.

```tsx
it('초기 상태에서는 알림이 없어야 한다', async () => {
  const { result: eventsResult } = renderHook(() => useEventOperations(false));

  await screen.findByText('일정 로딩 완료!');

  const events = eventsResult.current.events;

  const { result } = renderHook(() => useNotifications(events));

  expect(result.current.notifications).toEqual([]);
});
```

useEventOperations, useNotifications 등의 hook 내부에서 어떻게 구현이 되어있는지는 테스트하지 않았다.
이런 경우가 명세 기반 테스트이다.

### 올바른 테스트 코드

- 답변은 정적이어야할까? 동적이어도 될까?

처음 과제를 진행했을 때는 고정된 테스트 방식에 대해서 의문을 품었다.
데이터나 날짜를 변경하면 매번 결과값을 하드코딩으로 다시 작성하는 것이 매우 비효율적으로 보였다.
그래서 전부 동적으로 답변이 나오도록 작성했었다.

```ts
it('holidays는 오늘 날짜에 해당하는 공휴일 정보를 포함하고 있어야 한다', async () => {
  const { result } = renderHook(() => useCalendarView());

  const holidays = HOLIDAY_RECORD_BY_MONTH[format('YYYY-MM')];

  expect(result.current.holidays).toEqual(holidays);
});

it(`currentDate는 오늘 날짜인 ${format('YYYY-MM-DD')}이어야 한다`, () => {
  const { result } = renderHook(() => useCalendarView());

  assertDate(result.current.currentDate, new Date());
});
```

여기까지는 아마 취향차이 정도로 넘어갈 수 있을 것 같다. 문제 없을 것 같다.

그러나 "검색어에 맞는 이벤트만 필터링해야 한다" 라는 테스트의 결과값을 직접 filter해서 결과값을 추론한다면..?

```ts
 expect(result).toEqual(data.filter(...))
```

이런 테스트 코드를 작성하고 생각했다.
이거.. data.filter()도.. 테스트 돌려야하는거아니야...? 순간 내가 뭔 생각을한거야! 하며 잘못됐다고 느꼈다.

그래서 코치님들께 여쭙고 방향성을 정했다.

=> 테스트코드의 답변은 정적으로 작성하는 것이 좋다!
=> 복붙을 많이 이용하자!

- 동등 분할 그룹
  테스트 설계 기법 중 하나이다.

  입력값들을 의미적으로 동일한 결과를 내는 그룹으로 나누는 기법이다.

  아래 예시를 보면 "일정이 표시되지 않는다", "일정이 표시된다" 두 그룹으로 나뉜다.
  이 때는 의미가 있는 동등 분할 그룹이다.

  ```ts
  it('주별 뷰를 선택 후 해당 주에 일정이 없으면, 일정이 표시되지 않는다.', async () => {
    const user = userEvent.setup();

    vi.setSystemTime(new Date('2025-09-01'));

    ...

    expect(screen.queryByText('팀 회의')).not.toBeInTheDocument();
  });

  it('주별 뷰 선택 후 해당 일자에 일정이 존재한다면 해당 일정이 정확히 표시된다', async () => {
    const user = userEvent.setup();

    vi.setSystemTime(new Date('2025-09-12'));
    ...

    expect(within(weekViewContainer).getByText('팀 회의')).toBeVisible();
  });
  ```

  그러나 만약 아래처럼 같은 분할 그룹의 테스트를 여러번 하는 경우는 잘못된 테스트 설계다

  ```ts

   it('주별 뷰를 선택 후 9월 1주차에 일정이 없으면, 일정이 표시되지 않는다.', async () => {
    const user = userEvent.setup();

    ...

    expect(screen.queryByText('팀 회의')).not.toBeInTheDocument();
  });

  it('주별 뷰를 선택 후 9월 2주차에 일정이 없으면, 일정이 표시되지 않는다.', async () => {
    const user = userEvent.setup();

    ...

    expect(screen.queryByText('팀 회의')).not.toBeInTheDocument();
  });
  ```

  - 경계값 테스트
    테스트의 경계값에는 개발자의 실수가 많이 일어날 수 있는 위치이다.
    아래처럼 경계값이 올바르게 분류되는지 테스트하는 것은 의미있다.

```ts
it('주의 끝(일요일)에 대해 올바른 주의 날짜들을 반환한다', () => {
  expect(getWeekDates(new Date('2025-07-07'))).toEqual([
    new Date('2025-07-06'),
    new Date('2025-07-07'),
    new Date('2025-07-08'),
    new Date('2025-07-09'),
    new Date('2025-07-10'),
    new Date('2025-07-11'),
    new Date('2025-07-12'),
  ]);
});
```

 <!-- 예시

- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
  -->

### 학습 효과 분석

- 실무 적용 가능성
  회사에는 핵심기능이 옷편집, 옷등록, 코디등록 등등 앱 초기부터 있었던 기초기능이 있다.
  해당 기능들을 개선하거나 고도화할 때마다 레거시 코드들이 어떻게 동작하고 있는것이고, 기획도 잘 모르겠고, 기대값도 뭔지 모르겠는 경우가 많다. 스프린트에서 해당 작업을 하게 된다는 얘기만 들어도 머리가 아프고, 시간이 비정상적으로 많이 소모된다.

  원래는 어쩔 수 없지.. 싹 다 엎어버려야되는데, 기획부터 개발까지 새로 해야되는거 아니야? 라는 생각만 하고 있었는데, 이번에 테스트 코드를 작성하면서 생각이 조금 바뀌었다.

  오프님이 Q&A 섹션중 누군가 비효율적인 테스트코드 같다고 해도 테스트코드로 인해 심리적인 안정감을 받을 수 있다면 그걸로도 의미있다고 하셨다.
  이 말씀이 좀 와닿게 되는 것 같다. 옛날 기능을 건드릴 때마다 무슨 버그가 발생할지 모르겠으니 불안하고 작업하고 싶지 않았는데, 테스트코드로 나에게 심리적인 안정감을 준다면 개발하기가 정말 편할 것 같다.

- 테스트코드를 학습한 후 생각
  테스트 코드하면 엄청 멀게만 느껴졌고, 우리 회사처럼 작은, 빠르게 기능 개발하기 바쁜 곳은 의미가 없을 것이야. 라고만 생각했는데, 테스트 코드가 오히려 빠른 추친력을 줄 수도 있을 것 같다는 생각을 했다.
  회사에서 한달에 한번씩 팀 회고를 하는데, 이 때 테스트 코드에 대한 생각을 나눠보려고 한다.

<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
  -->

### 과제 피드백

테스트 코드를 처음 접하다보니 과제양이 벅차게 느껴지긴 했습니다.
그래서 난이도를 나눠주시긴 하셨지만,
쉬운걸 고르고 싶지 않았고... 심화과제 리팩토링은 과감하게 포기하고 테스트코드에 집중하여 학습하고자 하였습니다.
이런 경우에 제가 선택한 길이긴 하지만 심화과제 실패하는 것이 조금 아쉽게 느껴지네요 ㅜ

<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

## 리뷰 받고 싶은 내용

- handlersUtils 함수 로직
  과제의 핵심이 병렬로 실행했을 때 문제가 없어야한다고 하셨는데,
  테스트가 병렬로 돈다면, 여러곳에서 동시에 server.use로 override를 하면 문제가 생기는 것이 아닌가? 하는 걱정이 되었습니다.

테스트를 실행했을 때는 문제가 발생하지 않는데, 테스트가 병렬로 돈다는 의미가 동시에 테스트가 실행된다는 것은 아닌걸까요?

server.resetHandlers()를 해주지 않으면 외부 테스트에 영향주는 것을 보았을 때는 그렇지만은 아닌거같고.. 약간 혼란스러운 부분입니다.

- 회사에서 테스트 코드 도입하는 방법?
  위에 회고에 적은 것처럼 레거시 로직과 함께 개발할 때 필요성이 느껴진 것 같습니다.
  해당 포인트로 팀원들과 얘기해서 도입을 해볼까 싶은데, 준일님은 어떻게 생각하시나요?
  제가 새로운거 배웠다고 신나서 편협된 시각으로 지금 상황을 바라본게 아닐까? 걱정되었습니다.

- 테스트 코드의 기대값을 어디까지 정적으로 두어야하고 동적으로 만들어야할지? (이미 오프코치님께서 답변을 해주셨지만, 준일님께도 들어보고 싶네요 ㅎㅎ..)

예를 들어서
"검색어에 맞는 이벤트만 필터링해야 한다" 라는 테스트에서의 결과 기대값이 아래라면,

```ts
[
  {
    id: '2',
    title: '준일님 짱짱맨',
    date: '2025-10-15',
    startTime: '09:00',
    endTime: '10:00',
    description: '준일님 짱짱맨',
    location: '회의실 B',
    category: '업무',
    repeat: { type: 'none', interval: 0 },
    notificationTime: 10,
  },
];
```

정답에 대한 기대값을 정적으로 보관해야할지
아래처럼 filter로 돌아야되나 고민하였습니다.

```ts
eventList.filter(...)
```

filter의 로직이 도는순간 테스트코드를 테스트해야되는 상황이 오는게 아닌가? 라는 무한 테스트 굴레의 빠지는 상상을 해보았습니다.

그럼 무조건 정적으로 두어야하나? 싶다가도 아주 간단한 결과값인데도 정적으로 두는 것은 또 불필요한 것 같습니다.

예시로 들어보면,
"주간 뷰에서 다음으로 navigate" 하는 테스트입니다.

7일후, 7일전으로 이동하는 아주 간단한 로직임에도 이것도 정적인 데이터로 테스트결과값을 작성해놔야할지 고민입니다.

정적으로 두면 mock 데이터가 변경되면 테스트 결과값도 같이 매번 수정해줘야한다는 불편한 점이 있을텐데, 불편하더라도 올바른 테스트를 작성하려면 정적인 데이터를 사용해야할까요?

<!--
피드백 받고 싶은 내용을 구체적으로 남겨주세요
모호한 요청은 피드백을 남기기 어렵습니다.

참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62

모호한 요청의 예시)
- 코드 스타일에 대한 피드백 부탁드립니다.
- 코드 구조에 대한 피드백 부탁드립니다.
- 개념적인 오류에 대한 피드백 부탁드립니다.
- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.

구체적인 요청의 예시)
- 현재 함수와 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수를 더 명확하게 이름 지을 수 있는 방법에 대해 조언해주실 수 있나요?
- 현재 파일 단위로 코드가 분리되어 있지만, 모듈화나 계층화가 부족한 것 같습니다. 어떤 기준으로 클래스를 분리하거나 모듈화를 진행하면 유지보수에 도움이 될까요?
- MVC 패턴을 따르려고 했는데, 제가 구현한 구조가 MVC 원칙에 맞게 잘 구성되었는지 검토해주시고, 보완할 부분을 제안해주실 수 있을까요?
- 컴포넌트 간의 의존성이 높아져서 테스트하기 어려운 상황입니다. 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?
-->

## 힌트

2~29일 테스트

2~4일 테스트를 다 따로 돌리는것은
하나 실행하는것과 동일하다

다른날짜를 테스트하는 것은 무의미하다라고 작성함

동일한 그룹으로 판단되는건 하나의 테스트만 작성함

같은 그룹의 테스트케이스라면 중복으로 작성하지 않는다.

한함수에서 30일 31일 테스트한다고 했을 때 ?

https://junghan92.medium.com/%EB%B2%88%EC%97%AD-geeks-for-geeks-%ED%85%8C%EC%8A%A4%ED%8C%85-%EA%B8%B0%EB%B2%95-1f44d1c38af3
https://www.figma.com/board/GfV47zGUAHfX5WQ45zxT13/7%EC%A3%BC%EC%B0%A8---4-7%ED%8C%80---Q-A?node-id=0-1&p=f&t=yKgnBcIGRSnFllLb-0

findbytext

독립된 환경을 어떻게 만들것인가..

병렬로 테스트를 실행시킬 때

독립된 환경을 어떻게 구성할것이냐가 hard의 핵심임

미디엄 하시는 분들은 msw 유틸함수

dayjs사용해도되는지 물어보자!

테스트케이스 작성할 때 노출되는 설명이 빠르게 찾기 위해....

## 모킹을한다 = 실제환경과 유사하게 만드는 것이 신뢰도 높아지는것

최소한으로라도 하는거지

## 실패 메세지나 테스트 구조를 구체적으로 작성해서 에러낫을 때 파악하기가 쉬워야한다!!

테스트가 구체적으로 잘 되어있지 않으면, 빨리 문제 파악하기가 어렵다..?
내부 코드 분석 시간 줄임

테스트 작성할 때 가장 기본이 되는 규칙
개별로 변경되는 규칙

두개의 관점으로 나뉘어져있는데,
기본흐름은 어디에 모아둘것이고,,

핸들러 유틸을 통해 항상 해야될것이냐?

특정 케이스에서는 특정상황을 만들고싶은건가요? =>

테스트 운영할 때 API 모킹은 당연히 필요하지
기본적으로는..

내가 이 테스트케이스 구성하는데있어서 하나의 API 흐름 만들어놓고

내가 테스트하는데 있어서 이벤트 두개 필요한 경우있을 수 있지.
어떤경우에는 두개필요한 경우가있지
삭제해야돼서 두개만들어야되는 경우도있을것이고..
그관점에 있어서 두개의 테스트가 필요한데..
그러면 내가 전체 프로젝트에서 쓰는 데이터는 이건데
이테스트는 특별하게 데이터를 관리해야해!
지점지점마다 있을 수 있지.

그걸 각 테스트 케이스에서 설정하자는거죠.

테스트마다 모킹을 따로 해야하는거다.

API도 동일하다.

API도 테스트케이스마다
server.use(http....~~ )해서 변환을 주게될텐데
어딘가에서는 전체를 관통하는 테스트가 있을텐데,

그런 경우에 다른 테스트가 영향을 준다.

테스트에 대해서 데이터를 하나하나다맞출필요없다.

날짜를 전체글로벌로 잡았는데.,
이테스트가 구동되는 환경을 2024년으로 고정시킬거야
윤년테스트해야돼 날짜변경해야돼
그런경우는 해당 테스트케이스에서만 변경해야돼요
전체를 관통하는 날짜..

날짜를 변경함으로써 ..

응집도도 올라가고..

다시 돌아와서..

전체 설정
각각의 설정
두가지가 있을 겁니다.

병렬로 실행해도 문제 없게 만들어야한다는게 포인트

## 정적, 동적

정적으로 작성하는 것을 권장합니다.

filter 도는 것은 좋지않다!!

테스트 내에 반복문 수준 이상의 로직을 작성하지 않는 것이 좋다.

복붙이 주는.. 오히려 리팩토링 안하게 만드는 그런 장점이 있긴함.

스태틱하게 받는것을 추천한다.

테스트를 위한 테스트를 작성하지 않는 기준으로 작성해야함

## 테스트의 그룹..

엣지케이스에대한 그룹

동등 분할 기법
같은 분할에대해서는 테스트 하지 않는다.

근데 나중에 저 함수를 누가 수정해서 엣지케이스를 발생시키는 코드를 만들었다면...?
=> 너무 불확실한 미래. 그거에 대한 검증은 미리 구성해뒀거나 그렇지 않다면 고려하지 않는다.

## 테스트코드가 주는 안정감..

내가 작성한 테스트코드로 인해 심리적인 안정감.

통과하면서 오는 심리적인 안정감을 강조함

그 관점에서 이 테스트가 안정감을 불러일으킨다면 작성한다.
누군가는 비효율적이라고 생각하더라도..

정답은 없다..

많이 작성한다고 손해볼거없어~ 안정감을 받으면되지~~

## invalid한 그룹 valid한 그룹

invalid한 영역이 다 다른 그룹이라면 작성이 필요하겠지만
절대 들어올일 없으면 => 굳이 할 이유가 없음

예외처리를 내가 필요한 부분을 적절히 해야하는데,
잘못된 날짜 빈값, 유저에게 입력될 수 있는 경로가 있다면 검증이 필요.

그런 부분에 있어서 검증하는게 비용낭비라면 작성하지 않아도 괜찮다.

너무 추상적이네~~

## 값을 명확하게

테스트 설명을 작성할 때 어떤 경우에는 ‘입력한 날짜 기준으로 ~ 반환한다’처럼 범용적으로 쓰고 어떤 경우에는 ‘2025-07-01을 입력하면 ~ 반환한다’처럼 특정 값을 명시하게 되던데, 두 방식 중 어떤 상황에 어떤 표현을 쓰는 게 좋은지 기준이 있는지 궁금합니다

특정 값을 명시해서 작성하는게 더 좋다.

##

데이터를 구성하는데있어서
테스트케이스르 설계하는데있어서
고민해야되는 부분이
테스트케이스에 대한 사이즈를 고민해야된다.

가장 어려운 주제가
mocking
테스트 사이즈에 대해서 구분하는 것

- 모킹
  어디까지 모킹할것이냐
  정통파 디트로이파 등..

최소한의 단위로.. 구분
